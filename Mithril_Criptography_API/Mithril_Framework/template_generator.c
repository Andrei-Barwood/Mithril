//
//  template_generator.c
//  Mithril_Criptography_API
//
//  Created by Andres Barbudo on 20-08-25.
//

#include "template_generator.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int mithril_generate_all_files(const char* project_path) {
    printf("🚀 Generating all Mithril operation files...\n");
    
    const MithrilOperationConfig* operations = mithril_get_all_operations();
    int count = mithril_get_operations_count();
    
    for (int i = 0; i < count; i++) {
        if (!mithril_generate_single_operation(project_path, &operations[i])) {
            printf("❌ Failed to generate %s files\n", operations[i].operation_name);
            return 0;
        }
        printf("✅ Generated %s files\n", operations[i].operation_name);
    }
    
    return 1; // Success
}

int mithril_generate_specific_files(const char* project_path, const char** operation_names, int count) {
    const MithrilOperationConfig* all_operations = mithril_get_all_operations();
    int total_operations = mithril_get_operations_count();
    
    for (int i = 0; i < count; i++) {
        int found = 0;
        for (int j = 0; j < total_operations; j++) {
            if (strcmp(operation_names[i], all_operations[j].operation_name) == 0) {
                if (!mithril_generate_single_operation(project_path, &all_operations[j])) {
                    printf("❌ Failed to generate %s files\n", operation_names[i]);
                    return 0;
                }
                printf("✅ Generated %s files\n", operation_names[i]);
                found = 1;
                break;
            }
        }
        if (!found) {
            printf("⚠️  Operation '%s' not found\n", operation_names[i]);
        }
    }
    
    return 1;
}

int mithril_generate_single_operation(const char* project_path, const MithrilOperationConfig* config) {
    // Generate header file
    char header_path[512];
    snprintf(header_path, sizeof(header_path), "%s/%s.h", project_path, config->file_name);
    
    char* header_content = mithril_generate_header_template(config);
    if (!header_content) return 0;
    
    FILE* header_file = fopen(header_path, "w");
    if (!header_file) {
        free(header_content);
        return 0;
    }
    
    fprintf(header_file, "%s", header_content);
    fclose(header_file);
    free(header_content);
    
    // Generate source file
    char source_path[512];
    snprintf(source_path, sizeof(source_path), "%s/%s.c", project_path, config->file_name);
    
    char* source_content = mithril_generate_source_template(config);
    if (!source_content) return 0;
    
    FILE* source_file = fopen(source_path, "w");
    if (!source_file) {
        free(source_content);
        return 0;
    }
    
    fprintf(source_file, "%s", source_content);
    fclose(source_file);
    free(source_content);
    
    return 1; // Success
}

char* mithril_generate_header_template(const MithrilOperationConfig* config) {
    char* template = malloc(2048);
    if (!template) return NULL;
    
    // Convert filename to uppercase for header guard
    char header_guard[128];
    snprintf(header_guard, sizeof(header_guard), "%s_H", config->file_name);
    
    // Convert to uppercase
    for (int i = 0; header_guard[i]; i++) {
        if (header_guard[i] >= 'a' && header_guard[i] <= 'z') {
            header_guard[i] = header_guard[i] - 'a' + 'A';
        }
    }
    
    snprintf(template, 2048,
        "/*\n"
        " * %s.h\n"
        " * Auto-generated by Mithril Framework\n"
        " * %s\n"
        " */\n\n"
        "#ifndef %s\n"
        "#define %s\n\n"
        "#include \"fmpz.h\"\n\n"
        "#ifdef __cplusplus\n"
        "extern \"C\" {\n"
        "#endif\n\n"
        "/* %s */\n"
        "int %s(const fmpz_t a, const fmpz_t b, fmpz_t result);\n\n"
        "#ifdef __cplusplus\n"
        "}\n"
        "#endif\n\n"
        "#endif /* %s */\n",
        config->file_name,
        config->description,
        header_guard,
        header_guard,
        config->description,
        config->function_name,
        header_guard);
    
    return template;
}

char* mithril_generate_source_template(const MithrilOperationConfig* config) {
    char* template = malloc(1024);
    if (!template) return NULL;
    
    snprintf(template, 1024,
        "/*\n"
        " * %s.c\n"
        " * Auto-generated by Mithril Framework\n"
        " * %s\n"
        " */\n\n"
        "#include \"%s.h\"\n"
        "#include <stdio.h>\n\n"
        "int %s(const fmpz_t a, const fmpz_t b, fmpz_t result) {\n"
        "    /* Call the framework's %s function */\n"
        "    return %s(a, b, result);\n"
        "}\n",
        config->file_name,
        config->description,
        config->file_name,
        config->function_name,
        config->operation_name,
        config->framework_function);
    
    return template;
}
